###  Introducciﾃｳn 2: Hoisting, Closures, Callbacks, ﾃ［bito y This

---

##  Objetivo
Explorar a fondo cﾃｳmo funciona JavaScript "bajo el capﾃｳ", entendiendo su ejecuciﾃｳn, el contexto de las variables y funciones, y la asincronﾃｭa a travﾃｩs de callbacks.

---

## 沐ｹ 1. Hoisting

**ﾂｿQuﾃｩ es?**
Hoisting (elevaciﾃｳn) es el comportamiento por el cual las declaraciones de variables y funciones se "mueven" al inicio de su ﾃ｡mbito antes de que el cﾃｳdigo se ejecute.

** Importante:**
- Solo las **declaraciones** se elevan, no las **asignaciones**.
- `var` se eleva con valor `undefined`.
- `let` y `const` son hoisted pero quedan en la **zona muerta temporal**.

** Ejemplo:**
```js
console.log(x); // undefined
var x = 5;

console.log(y); // ReferenceError
let y = 10;
```

## Ejercicio:
ﾂｿQuﾃｩ imprime el siguiente cﾃｳdigo y por quﾃｩ?
```js
saludar();
function saludar() {
  console.log("Hola");
}

despedir();
var despedir = function() {
  console.log("Adiﾃｳs");
};

```

## 2. ﾃ［bito (Scope)
# ﾂｿQuﾃｩ es?
El ﾃ｡mbito define dﾃｳnde una variable es accesible. JavaScript tiene:
> ﾃ［bito global
> ﾃ［bito de funciﾃｳn
> ﾃ［bito de bloque (con let y const)

# Ejemplo:
```js
function ejemplo() {
  let mensaje = "Hola";
  if (true) {
    let mensaje = "Adiﾃｳs";
    console.log(mensaje); // Adiﾃｳs
  }
  console.log(mensaje); // Hola
}
```

# Ejercicio:
ﾂｿQuﾃｩ imprime este cﾃｳdigo?
```js
var a = 1;
function test() {
  var a = 2;
  console.log(a);
}
test();
console.log(a);
```

#  3. Closures
ﾂｿQuﾃｩ es?
Un closure es una funciﾃｳn que recuerda el entorno en el que fue creada, incluso si se ejecuta fuera de ese contexto.
```js
function crearContador() {
  let contador = 0;
  return function () {
    contador++;
    return contador;
  };
}

const contar = crearContador();
console.log(contar()); // 1
console.log(contar()); // 2
```

# Ejercicio:

Crea una funciﾃｳn multiplicador(n) que devuelva una nueva funciﾃｳn que multiplique su argumento por n.
Ejemplo:
```js
const porCinco = multiplicador(5);
console.log(porCinco(2)); // 10
```
 4. Entorno Lﾃｩxico (Lexical Environment)
ﾂｿQuﾃｩ es?
El entorno lﾃｩxico es el contexto fﾃｭsico donde se declarﾃｳ una variable. Las funciones acceden primero a las variables de su entorno actual y luego suben hacia entornos superiores (scope chain).
```js
const nombre = "Ana";

function mostrarNombre() {
  console.log(nombre);
}
function ejecutar() {
  const nombre = "Luis";
  mostrarNombre(); // ﾂｿAna o Luis?
}
ejecutar();
```

# 5. Callbacks
ﾂｿQuﾃｩ es?
Un callback es una funciﾃｳn que se pasa como argumento a otra funciﾃｳn para que sea ejecutada mﾃ｡s tarde.
```js
function procesar(nombre, callback) {
  console.log("Hola " + nombre);
  callback();
}

procesar("Sofﾃｭa", function() {
  console.log("ﾂ｡Bienvenida!");
});
```

# Ejercicio:
Crea una funciﾃｳn sumaAsync(a, b, callback) que sume dos nﾃｺmeros y luego llame al callback con el resultado.

## 沐 Comportamiento de `this` en JavaScript

El valor de `this` en JavaScript varﾃｭa segﾃｺn el **contexto de ejecuciﾃｳn**. A continuaciﾃｳn, se muestra un resumen:

| Contexto                | Valor de `this`                          |
|-------------------------|------------------------------------------|
| En una funciﾃｳn global   | `window` (en navegador) / `global` (Node.js) |
| En un mﾃｩtodo de objeto  | El **objeto** al que pertenece el mﾃｩtodo |
| En una funciﾃｳn flecha   | Hereda el `this` del **contexto exterior** |

---

###  Ejemplo prﾃ｡ctico:

```js
// Funciﾃｳn global
function globalFunction() {
  console.log(this); // window en navegador
}
globalFunction();

// Mﾃｩtodo de objeto
const persona = {
  nombre: "Carlos",
  saludar: function () {
    console.log(this.nombre); // Carlos
  }
};
persona.saludar();

// Funciﾃｳn flecha
const persona2 = {
  nombre: "Luisa",
  saludar: () => {
    console.log(this.nombre); // undefined (hereda del contexto exterior)
  }
};
persona2.saludar();
```